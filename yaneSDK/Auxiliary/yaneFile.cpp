#include "stdafx.h"
#include "yaneFile.h"
#include "yaneLZSS.h"
#include "yaneStringScanner.h"
#include "../AppFrame/yaneAppInitializer.h"

namespace yaneuraoGameSDK3rd {
namespace Auxiliary {

#ifndef COMPILE_YANE_PLUGIN_DLL

//	CFile????????p?I?u?W?F?N?g
CFile::CFileInitializer::CFileInitializer(){
	//	BCC??????I??L???X?g???????I?[?o?[???[?h????????????????
	void(*f)() = &CFile::SetCurrentDir;
	CAppInitializer::RegistInitCallback( smart_ptr<function_callback>(function_callback_v::Create(f)) );
}
CFile::CFileInitializer m_dummy;

#else
//?@?d????????ACAppInitializer::DllInit?????????????..
#endif

//////////////////////////////////////////////////////////////////////////////

string	CFile::m_strCurrentDirectory;		// ?????????????f?B???N?g??
smart_ptr<vector<string> >	CFile::m_astrPathList;	// ?p?X???X?g

//////////////////////////////////////////////////////////////////////////////
//	<yanepack?p?\?????????>
//		?t?@?C???w?b?_?[ "yanepack" 8?o?C?g + ?i?[?t?@?C???? DWORD
//		?????A?????CFileInfo???i?[?t?@?C????????????A?????f?[?^
struct CFileInfo {
	CHAR	filename[32];
	DWORD	startpos;	//	seek pos
	size_t	filesize;	//	file size
};
struct CFileInfoEx {
	CHAR	filename[32];
	DWORD	startpos;	//	seek pos
	size_t	filesize;	//	file size(?W?J???t?@?C???T?C?Y)
	size_t	arcsize;	//	arc size (???k?T?C?Y)
};
struct CFileInfoDx {
	CHAR	filename[256];	//	?K?w???t?@?C??????A?T?C?Y????????
	DWORD	startpos;	//	seek pos
	size_t	filesize;	//	file size(?W?J???t?@?C???T?C?Y)
	size_t	arcsize;	//	arc size (???k?T?C?Y)
};
//////////////////////////////////////////////////////////////////////////////

CFile::CFile() {
	m_lpFile = NULL;
	m_lpFileAdr		= NULL;
	m_dwFileSize	= 0;
	m_lpFileMemPos	= NULL;
	m_bEncode		= false;
	m_bTempFile		= false;
	m_bCompress		= false;
	m_bMemoryImage	= false;
}

CFile::~CFile() {
	Close();
}

LRESULT CFile::Close(){
	if (m_lpFile!=NULL) {
		LRESULT l;
		l = ::fclose(m_lpFile);
		m_lpFile = NULL;
		return l;
	}
	if (m_bMemoryImage) {
	//	???????????z?t?@?C??
		m_lpFileAdr = NULL;
		m_dwFileSize = 0;
		m_lpFileMemPos = NULL;
		m_bMemoryImage = false;
	}
	if (m_lpFileAdr!=NULL) {
		::GlobalFree(m_lpFileAdr);
//		delete [] m_lpFileAdr;
		m_lpFileAdr = NULL;
		m_dwFileSize = 0;
		m_lpFileMemPos = NULL;
	}
	if (m_bTempFile) {
		m_bTempFile = false;
		Delete(m_strFileName);	//	?t?@?C?????
	}
	m_bCompress	= false;
	m_strFileName.erase();
	return 0;
}

//	?t?@?C?????
LRESULT	CFile::Delete(const string& filename){
	//	??????n?????...
	if (filename.empty()) return -1;

	string fn(MakeFullName(filename));
	return !::DeleteFile(fn.c_str());
}

LRESULT	CFile::CreateTemporary(bool bForce/* = false*/){
	if (m_lpFileAdr==NULL && !bForce) return 1;
	if (m_bCompress || m_bMemoryImage || bForce) {
	//	???k?t?@?C?????A???????C???[?W?i?t?@?C????????????j
	//	???????duplicate????

		string strTmpFileName;
		LRESULT lr = GetTemporaryFileName(strTmpFileName);
		if (lr!=0) return 2;

		if (WriteBack(strTmpFileName) != 0) {
//			Err.Out("CFile::CreateTemporary::?e???|?????t?@?C??????????????B");
			return 2;
		}
		Close();
		//	write back???????????????K?????????t?@?C?????????
		m_bTempFile = true;
		m_strFileName = strTmpFileName;
	} else {
		//	????????AClose?????????????????S?O?O?G
		string s;
		s = m_strFileName;
		Close();
		m_strFileName = s;
	}
	return 0;
}


LRESULT	CFile::GetTemporaryFileName(string& strFileName){
	//	?e???|?????t?@?C??????????

	CHAR	szTmpPath[MAX_PATH];
	CHAR	szTmpFileName[MAX_PATH];
	if (::GetTempPath(sizeof(szTmpPath), szTmpPath) == 0) {
//		Err.Out("CFile::CreateTemporary::?e???|?????p?X???????????B");
		return 2;
	}
	if (::GetTempFileName(szTmpPath, "YNE", 0, szTmpFileName) == 0) {
//		Err.Out("CFile::CreateTemporary::?e???|?????t?@?C?????????????B");
		return 2;
	}
	strFileName = szTmpFileName;
	return 0;
}

//////////////////////////////////////////////////////////////////////////////
string CFile::GetCurrentDir() {
	if (m_strCurrentDirectory.empty()) {
		//	??????????A?????
		CHAR dir[_MAX_PATH];
		::GetCurrentDirectory(_MAX_PATH,dir);
		SetCurrentDir(dir);
	}
	return m_strCurrentDirectory;
}

void CFile::SetCurrentDir(){
	CHAR dir[_MAX_PATH];
	::GetCurrentDirectory(_MAX_PATH,dir);
	SetCurrentDir(dir);
}

void CFile::SetCurrentDir(const string& dir){

	bool bDir = false;
	m_strCurrentDirectory = dir;
	if (!m_strCurrentDirectory.empty() && m_strCurrentDirectory[0]=='"') {
		bDir = true;
		m_strCurrentDirectory.erase(0,1);	// ?R?}???h???C????n???????...
	}
	// c:\test\test.exe?@?????R?}???h???C????????J?????g?f?B???N?g????
	// ??????????H?v?B(bDir==true????)
	// c:\test\?@???B????\?????????B

	string::size_type pos;
	if (bDir) {
		pos = m_strCurrentDirectory.find('.');
	} else {
		pos = string::npos;
	}
	string::iterator it;
	if (pos==string::npos) {		// . ??????????
		if (m_strCurrentDirectory.empty()) {
			// Empty path: treat as root, append backslash
			m_strCurrentDirectory += '\\';
		} else {
			it = m_strCurrentDirectory.end() - 1;
			if (*it!='\\' && *it!='/') {
				// \??/??I?????????????\????
				m_strCurrentDirectory += '\\';
			}
		}
	} else { // c:\test\test or c:\test\test.exe
		GetParentDir(m_strCurrentDirectory);
	}
}

LRESULT	CFile::GetParentDir(string& filename){						//	?e?t?H???_????
// e.g. "c:\test1\test2\test3.exe" -> "c:\test1\test2\" -> "c:\test1\" -> "c:\" -> "c:\"
	//	??????P?o?C?g????????K?v????...
	//
	//	1. ?????A?l?b?g???[?N?h???C?u??L???A?R???s???[?^?????X?L?b?v????B
	//	?@?@???????????A???[?J????p?X?????????????B
	//?@?@?@?i\\HOST\PATH ?????A?h???C?u???^?[????????? ?? ?d?l
	//	2. \??/??T???B???????????????????u??????Q??????????????u???L?^???????
	//	3. ??????\???/?????????A???[?g???????t??????B???[?g???????A???@?@?@?@?@??????????????????e?f?B???N?g?????????
	//	4. ??????\ ?? /???????@?A???[?g????????????B???[?g???????A?????Q????????????????????e?f?B???N?g?????????
	//
	//	2001/07/29 sohei
	//	  ???[?g??L??t?@?C??????n??????\??/?????????????A???[?g???????????????
	//	2001/08/06 sohei
	//	  string ?? \ ??t?????????g?????????A?o?O?????C??
	//	?@????????????`?@??????L?????????????B

	if (filename.empty()) return 1;	//	??????n????^^;

	string::iterator it = filename.begin();
	if (filename.size() >= 2 && filename.substr(0,2)=="\\\\") {
		//	?l?b?g???[?N?p?X
		it += 2;
		if (it == filename.end() || *it == '\0')	return 1;	//	\\ ??????????^^;
		//	????????A?R???s???[?^?????X?L?b?v????
		bool bKanji=false;
		for(;;){
			if (it == filename.end()) break;
			if (*it == '\0') break;
			if (bKanji) { bKanji=false; it++; continue; }
//			if (((BYTE)*it>=0x80 && (BYTE)*it<=0xa0) || ((BYTE)*it>=0xe0 && (BYTE)*it<=0xff)) {
			if (  CStringScanner::IsLead_ShiftJIS(*it)  ){
				bKanji = true;	//	?Q?o?C?g?R?[?h??P?o?C?g????????
			} else {
				bKanji = false;	//	?Q?o?C?g?R?[?h??P?o?C?g??????????
				if (*it == '\\' || *it=='/') {	//	??????
					it++;	//	\\HOST\ ??????????????[?J???????????????
					break;
				}
			}
			it++;
		}
	} else {
	}
	string::iterator pos1,pos2;	
	// pos1 : ????????????\??/???u
	// pos2 : ?????Q????????????\??/???u
//	pos1 = pos2 = string::npos;	// not found
	pos1 = pos2 = filename.end();	// not found

	bool bKanji=false;
	
	while (it != filename.end()) {
		if (*it == '\0') break;
		if (bKanji) { bKanji=false; goto skip; }
//		if (((BYTE)*it>=0x80 && (BYTE)*it<=0xa0) || ((BYTE)*it>=0xe0 && (BYTE)*it<=0xff)) {
		if ( CStringScanner::IsLead_ShiftJIS(*it) ){
			bKanji = true;	//	?Q?o?C?g?R?[?h??P?o?C?g????????
		} else {
			bKanji = false;	//	?Q?o?C?g?R?[?h??P?o?C?g??????????
			if (*it == '\\' || *it=='/') {	//	??????
				pos2 = pos1;
				pos1 = it;
			}
		}
skip:;
		it++;
	}
	//	2001/08/06	sohei
	//		string ???L???????????A?C?e???[?^????????????A
	//		?s??????????????N?????????????C???B
	//		????????????`?@????L?????????????B

	//	??????\???/?????????
	if ( it != filename.begin() && !bKanji && (*(it-1)!='\\' && *(it-1)!='/') ) {
		//	?????????????????????????K?v?B
		if (pos1 == filename.end()) {	//	????\??????????[?g????\??t??????
			filename+='\\';
		} else {
			filename.erase(pos1+1,filename.end());	//	???[?g????????A??????????????????????
		}
	} else {
		//	???????Q???????????????????K?v?B
		if (pos2 == filename.end()) return 1;	//	???[?g?????????K?v????
		filename.erase(pos2+1,filename.end());		//	?????Q???????????
	}
	return 0;
}

string	CFile::GetSuffix()const{
	return GetSuffixOf(m_strFileName);
}

string	CFile::GetPureFileName()const{
	return GetPureFileNameOf(m_strFileName);
}

// ------ static function ------
string	CFile::GetSuffixOf(const string& filename){
	string suffix;
	suffix = GetPureFileNameOf(filename);
	// ?@?@?@?@?????f?B???N?g???L????????????????p?X??????
	string::size_type pos;
	pos = suffix.rfind('.');
	if (pos==string::npos) {
		suffix.erase();
	} else {
		suffix.erase(0,pos+1);
	}
	return suffix;
}	

string	CFile::GetPureFileNameOf(const string& filename){

	if (filename.empty()) return string("");

	string purefilename;
	string::iterator pos1;
	// pos1 : ????????????\??/???u
	purefilename = filename;
	string::iterator it = purefilename.begin();
	pos1 = purefilename.end();	// not found
	bool bKanji=false;
	while (it != purefilename.end()) {
		if (*it == '\0') break;
		if (bKanji) { bKanji=false; goto skip; }
//		if (((BYTE)*it>=0x80 && (BYTE)*it<=0xa0) || ((BYTE)*it>=0xe0 && (BYTE)*it<=0xff)) {
		if ( CStringScanner::IsLead_ShiftJIS(*it) ){
			bKanji = true;	//	?Q?o?C?g?R?[?h??P?o?C?g????????
		} else {
			bKanji = false;	//	?Q?o?C?g?R?[?h??P?o?C?g??????????
			if (*it == '\\' || *it=='/') {
				pos1 = it;
			}
		}
skip:;
		it++;
	}
	if (pos1!=purefilename.end()){
		purefilename.erase(purefilename.begin(),pos1+1);
	}
	return purefilename;
}

//////////////////////////////////////////////////////////////////////////////
//	static function..
void  CFile::ToLower(string &str){
	//	????????????(do_tolower)
	string::iterator it = str.begin();
	bool bSkip = false;
	while (it!=str.end()){
		if (bSkip) {
			bSkip = false;
			goto Repeat;
		}

//		if (((BYTE)*it>=0x80 && (BYTE)*it<=0xa0) || ((BYTE)*it>=0xe0 && (BYTE)*it<=0xff)) {
		if ( CStringScanner::IsLead_ShiftJIS(*it) ){
			//	?Q?o?C?g?R?[?h??P?o?C?g????????
			bSkip = true;
			goto Repeat;
		} else {
			//	?Q?o?C?g?R?[?h??P?o?C?g??????????
			bSkip = false;
		}
		*it = tolower(*it);
Repeat:;
		it ++;
	}
}
//////////////////////////////////////////////////////////////////////////////

LRESULT CFile::Open(const string& filename,const string& access)
{
	LRESULT lr;
	//	?J?????g?t?H???_???????
	lr = InnerOpen(MakeFullName(filename), access);
	if (lr==0) return 0;

	if (GetPathList().isNull()) return lr;	//	?p?X?w????????????D?D?O?O?G

	//	??????????p?X?????????????????
	pathlist::iterator it = GetPathList()->begin();
	while (it!=GetPathList()->end()){
		lr = InnerOpen(*it + '/' + filename, access);
		if (lr == 0) return 0; // ??????????O?O?G
		it++;
	}
	return lr;	//	?????????????A?A?i?????j
}

LRESULT CFile::InnerOpen(const string& filename,const string& access)
{
	Close();
	m_lpFile = fopen(filename.c_str(), access.c_str());
	if (m_lpFile==NULL) return 1;

	// ?t?@?C????????
	m_strFileName = filename;
	return 0;
}

LRESULT CFile::Write(const string& s) {
	if (m_lpFile==NULL) return -1;
	if (fprintf(m_lpFile,"%s",s.c_str())<0) return 1;
	return 0;
}

LRESULT	CFile::WriteBack(const string& filename){
	return Write(filename,GetMemory(),GetSize());
}

//////////////////////////////////////////////////////////////////////////////

DWORD	CFile::GetSize() const {
	if (m_bEncode) return m_dwFileSize - 4;	//	?S?o?C?g????
	return m_dwFileSize;
}

LPVOID	CFile::GetMemory() const {
	if (m_bEncode) return (BYTE*)m_lpFileAdr + 4;	//	????w?b?_??S?o?C?g?????
	return m_lpFileAdr;
}

LRESULT	CFile::Encode(){
	if (*(DWORD*)m_lpFileMemPos == 0x314B5059) return 1;	// already encoding!!
	if (m_bEncode) return 1;	//	already encoding!!
	
	DWORD size = m_dwFileSize+4;
	BYTE* m_lpFileAdr2 // = new BYTE[size+1];
		= (BYTE*)GlobalAlloc(GMEM_FIXED | GMEM_NOCOMPACT,size+1);

	//	?P?o?C?g?????m?????A????\0???????B?????????A
	//	???????r?????????????B
	*((BYTE*)m_lpFileAdr2 + size) = 0;

	for (DWORD i=0;i<size-4;i++){
		//	?j?u?????????????:p
		*(m_lpFileAdr2+i+4) =	(((*((BYTE*)m_lpFileAdr+i) & 0xf) << 4) +
								 ((*((BYTE*)m_lpFileAdr+i) &0xf0) >> 4)) ^ 0xcc;
	}
	*(DWORD*)m_lpFileAdr2 =	 0x314B5059;	// YPK1:?w?b?_?t?^

	Close();

	m_lpFileAdr		= (LPVOID)m_lpFileAdr2;
	m_dwFileSize	= size;
	m_lpFileMemPos	= (LPCSTR)m_lpFileAdr; // for ReadLine
	m_bEncode		= false;	//	??????false????????????w?b?_?[?t?^
	return 0;
}

string	CFile::GetWindowsDir(){
	//	?V?X?e???f?B???N?g?????i?I?[??\\?j
	CHAR	buf[MAX_PATH];
	::GetWindowsDirectory(buf,MAX_PATH);
	if (buf[::lstrlen(buf)-1]!='\\'){	//	?I?[??'\'???H
		::lstrcat(buf,"\\");
	}
	return buf;	//	?R?s?[?R???X?g???N?^???N??????????S
}

//////////////////////////////////////////////////////////////////////////////
string	CFile::MakeFullName(const string& filename){	// ?N???f?B???N?g??????????S?p?X?????
	string file;
	if (filename.substr(0,2)=="\\\\") {
			//	?l?b?g???[?N?p?X????????????
			file = filename;
	} else {
		string::size_type pos = filename.find(':');
		if (pos==string::npos) {
			//	?t???p?X???????J?????g?f?B???N?g?????

			// ..\\??????????p?X???T?|?[?g
			string dir;
//			dir = m_strCurrentDirectory;
			dir = GetCurrentDir();
				//	???????????????A????u???????
			file = filename;
			while (true) {
				if (file.substr(0,3)=="..\\" || file.substr(0,3)=="../"){
					GetParentDir(dir);
					file.erase(0,3);
				} else if ((file.substr(0,2)==".\\" || file.substr(0,2)=="./")) {
					//	./????J?????g?t?H???_??????
					file.erase(0,2);
				} else if (!CStringScanner::IsLead_ShiftJIS(file.at(0))&&(file.substr(0,1)=="\\" || file.substr(0,1)=="/")){
					//	\?P??????????  ?}???`?o?C?g??????1byte????l??????
					file.erase(0,1);
				} else {
					break;
				}
			}
			file = dir + file;
		} else {
			file = filename;
		}
	}
	/*
		'01/10/07	??????
			/	??????????????????????????????A\??u??????O?O?G
		'02/02/11	????
			?}???`?o?C?g???l?????????????????C??????
			?t?@?C???????`?F?b?N??????A??????????GetPath??T?????????
	*/


//	?R?????g?A?E?g by ?????? '02/03/14 01:36
#if 0

	// GetPath()!=NULL????A?w?????t?@?C????????????`?F?b?N
	if(!GetPath().isNull()){
		bool bFound = false;
		if(!PathFileExists(file)){
			// ???k??????????
			string fullname(file);
			string inner_filename(fullname);
			GetParentDir(fullname);
			inner_filename.erase(0, fullname.size());
			fullname[fullname.size() - 1] = '.';
			fullname += "dat";
			if(PathFileExists(fullname)) { bFound=true; }	// ???k?t?@?C?????????????
		}else{
			bFound=true;
		}

		// ?????????????????????????
		if(!bFound){
			const string file2 = file;
			vector<string>::iterator it = GetPath()->begin();
			while(it!=GetPath()->end()){
				file = *it + '/' + filename;
				if(!PathFileExists(file)){
					// ???k??????????
					string fullname(file);
					string inner_filename(fullname);
					GetParentDir(fullname);
					inner_filename.erase(0, fullname.size());
					fullname[fullname.size() - 1] = '.';
					fullname += "dat";
					if(PathFileExists(fullname)) { bFound=true;	 break; }	// ???k?t?@?C?????????????
				}else{
					bFound=true;  break;
				}
				it++;
			}
			// ???????????????A?J?????g????????????
			if(!bFound) { file = file2; }
		}
	}
#endif

	{
		bool bKanji=false;
		string::iterator it = file.begin();
		while (it!=file.end()){
			if( CStringScanner::IsLead_ShiftJIS(*it) ){
				//	?Q?o?C?g?R?[?h??P?o?C?g????????
				bKanji=true;
			}else{
				//	?Q?o?C?g?R?[?h??P?o?C?g??????????
				if(!bKanji && *it == '/') { *it='\\'; }
				bKanji=false;
			}
			it++;
		}
	}

	return file;
}

bool CFile::PathFileExists(const string& fullname)
{
	HANDLE hFile = ::CreateFile(fullname.c_str(),
		GENERIC_READ,		// Read
		FILE_SHARE_READ,	// ReadOpen????L?????????}?i?[ 
		NULL,				// security
		OPEN_EXISTING,		// ????????????G???[
		FILE_ATTRIBUTE_NORMAL,	//	?t?@?C??????
		NULL				// ?e???v???[?g?t?@?C??
	);

	if (hFile == INVALID_HANDLE_VALUE) { // ????????I
		// close????K?v????(INVALID?n???h???????)
		return false;
	}
	::CloseHandle(hFile);
	return true;
}

//////////////////////////////////////////////////////////////////////////////

LRESULT CFile::Read(const string& strFileName){
	LRESULT lr;
	//	?J?????g?t?H???_???????
	lr = InnerRead(strFileName);
	if (lr==0) return 0;

	if (m_astrPathList.isNull()) return lr;	//	?p?X?w????????????D?D?O?O?G

	//	??????????p?X?????????????????
	pathlist::iterator it = m_astrPathList->begin();
	while (it!=m_astrPathList->end()){
		lr = InnerRead(*it + '/' + strFileName);
		if (lr == 0) return 0; // ??????????O?O?G
		it++;
	}
	return lr;	//	?????????????A?A?i?????j
}

#pragma warning(disable:4701) // ?l????????????????????warning
LRESULT CFile::InnerRead(const string& filename){

	if (filename.empty()) return -1; // ????H

	DWORD NumberOfBytesRead;
	int nFileType = 0;
	//	0:?????t?@?C?? 1:yanePack
	//	2:yanePackEx 3:yanePackDx

	DWORD dwReadSize;	// ??????T?C?Y

	Close(); // ?O???????????A??????????????I
	m_strFileName = filename;

	if (filename[0] == '!') {
		//	???????C???[?W (hex address, hex size)
		unsigned long uAddr = 0, uSize = 0;
		if(::sscanf(filename.c_str(),"!%lx,%lx",&uAddr,&uSize)!=2) {
			return 6; // ?????????t?@?C?????????H
		}
		m_lpFileAdr = (LPVOID)(void*)(ULONG_PTR)uAddr;
		m_dwFileSize = (DWORD)uSize;
		m_lpFileMemPos	= (LPCSTR)m_lpFileAdr;
		m_bMemoryImage	= true;
		return 0;
	}
	m_bMemoryImage = false;

	string fullname;
	fullname = MakeFullName(filename);
	HANDLE hFile = ::CreateFile(fullname.c_str(),
		GENERIC_READ,		// Read
		FILE_SHARE_READ,	// ReadOpen????L?????????}?i?[ 
		NULL,				// security
		OPEN_EXISTING,		// ????????????G???[
		FILE_ATTRIBUTE_NORMAL,	//	?t?@?C??????
		NULL				// ?e???v???[?g?t?@?C??
	);

	if (hFile == INVALID_HANDLE_VALUE) { // ????????I
		// close????K?v????(INVALID?n???h???????)

		//	???????????k?t?@?C?????H
		//	test/script/game.c
		//	?? test/script.dat??game.c??T??
		//	?? test.dat??script/game.c??T??
		//	?????????????????????????????

		/*
		string::size_type pos1,pos2;
		pos1 = fullname.rfind('/');
		pos2 = fullname.rfind('\\');
		//	??????L???????????????????????l????????B
		//	?????????????~???????
		if (pos1 == string::npos) pos1=0;
		if (pos2 == string::npos) pos2=0;
		if (pos2 > pos1) pos1 = pos2;
		string inner_filename;
		inner_filename = fullname.substr(pos1+1,string::npos);
		fullname.erase(pos1);
		fullname += ".dat";
		*/

		//	fixed by TearDrop_Stone
		string inner_filename(fullname);
		string dirname(fullname);

	//	---- ???k?t?@?C?????????????????A??????g???C???[?v
CompressFileRetry:;

		GetParentDir(dirname);
		{
			string temp(dirname);
			GetParentDir(temp);
			if (temp==dirname){
				return 1;	//	??????A????????????
			}
		}

		inner_filename = fullname.substr(dirname.size()
			,fullname.length()-dirname.length());
		dirname[dirname.size() - 1] = '.';
		dirname += "dat";

		hFile = ::CreateFile(dirname.c_str(),
			GENERIC_READ,		// Read
			FILE_SHARE_READ,	// ReadOpen????L?????????}?i?[ 
			NULL,				// security
			OPEN_EXISTING,		// ????????????G???[
			FILE_ATTRIBUTE_NORMAL,	//	?t?@?C??????
			NULL				// ?e???v???[?g?t?@?C??
		);

		if (hFile == INVALID_HANDLE_VALUE) {
			goto CompressFileRetry;
		}

		//	???k?t?@?C??????????????I
		CHAR ident[9];
		ident[8] = '\0';
		if (!::ReadFile(hFile,ident,8,&NumberOfBytesRead,NULL)){
			::CloseHandle(hFile);
			goto CompressFileRetry;
		}
		if (!strcmp(ident,"yanepack")) nFileType = 1;
		else if (!strcmp(ident,"yanepkEx")) nFileType = 2;
		else if (!strcmp(ident,"yanepkDx")) nFileType = 3;
		if (nFileType==0) {
			::CloseHandle(hFile);
			goto CompressFileRetry;
		}

		DWORD filenum;
		if (!::ReadFile(hFile,&filenum,sizeof(filenum),&NumberOfBytesRead,NULL)){
			::CloseHandle(hFile);
			goto CompressFileRetry;
		}
		
		bool bFound = false;
		
		ToLower(inner_filename);
		CFileInfo info;
		CFileInfoEx infoEx;
		CFileInfoDx	infoDx;
		DWORD dwStartPos; // ?t?@?C???J?n?I?t?Z?b?g
		for(int i=0;i<(int)filenum;i++){
			string s;
			switch (nFileType){
			case 1: // yanePack
				if (!::ReadFile(hFile,&info,sizeof(info),&NumberOfBytesRead,NULL)){
					::CloseHandle(hFile);
					goto CompressFileRetry;
				}
				s = info.filename;	//	???????????????e?X?g????
				break;
			case 2: // yanePackEx
				if (!::ReadFile(hFile,&infoEx,sizeof(infoEx),&NumberOfBytesRead,NULL)){
					::CloseHandle(hFile);
					goto CompressFileRetry;
				}
				s = infoEx.filename;	//	???????????????e?X?g????
				break;
			case 3: // yanePackDx
				if (!::ReadFile(hFile,&infoDx,sizeof(infoDx),&NumberOfBytesRead,NULL)){
					::CloseHandle(hFile);
					goto CompressFileRetry;
				}
				s = infoDx.filename;	//	???????????????e?X?g????
				break;
			}
			ToLower(s);
			if (s == inner_filename) {
				//	??v?????I
				// info.startpos??Seek
				switch (nFileType){
				case 1:	m_dwFileSize = info.filesize;
						dwReadSize	 = info.filesize;
						dwStartPos	 = info.startpos;
					break;
				case 2:	m_dwFileSize = infoEx.filesize;
						dwReadSize	 = infoEx.arcsize;
						dwStartPos	 = infoEx.startpos;
					break;
				case 3:	m_dwFileSize = infoDx.filesize;
						dwReadSize	 = infoDx.arcsize;
						dwStartPos	 = infoDx.startpos;
					break;
				}
				bFound = true;
				break;
			}
		}
		if (!bFound) {
			::CloseHandle(hFile);
			//	????????????????
			goto CompressFileRetry;
		}
		m_bCompress	= true;	//	??????????????O?O?G
		if (::SetFilePointer(hFile,dwStartPos,NULL,FILE_BEGIN)==0xFFFFFFFF) {
			::CloseHandle(hFile);
			goto CompressFileRetry;
		}
		goto StartOfRead;
	}
	
	// 4GB????t?@?C???????????????????????l???????
	m_dwFileSize = ::GetFileSize(hFile,NULL);
	
	if (m_dwFileSize == 0xFFFFFFFF) {
		m_dwFileSize = 0;
		::CloseHandle(hFile);
		// Err.Out("CFile::ReadFile??FileSize?????s");
		return 2; // filesize???????s?B?i?????????v??????j
	}

	//	??????T?C?Y
	dwReadSize = m_dwFileSize;

StartOfRead:;
	//	???????????????????m??I
	m_lpFileAdr = (LPVOID)::GlobalAlloc(GMEM_FIXED | GMEM_NOCOMPACT,m_dwFileSize+1);

	// m_lpFileAdr = new BYTE[m_dwFileSize+1];

	// ??????????g?????A????G???A???k???????[??B
	if (m_lpFileAdr==NULL) {
		::CloseHandle(hFile);
		// Err.Out("CFile::ReadFile????????m????s");
		return 3; // ???????m????????????B
				  // ?????t?@?C?????????????????[?i??j
	}
	//	?P?o?C?g?????m?????A????\0???????B?????????A
	//	???????r?????????????B
	*((BYTE*)m_lpFileAdr + m_dwFileSize) = 0;

	if ((nFileType==2||nFileType==3) && (m_dwFileSize!=dwReadSize)) {
		//	???k?t?@?C????????O???????
		smart_ptr<BYTE> lpBuf;
		lpBuf.AddArray(dwReadSize);
		if (lpBuf.isNull()) {
		//	???????????????????:p
			Close();
			::CloseHandle(hFile); // ?????...
			return 4;
		}
		if (!::ReadFile(hFile,lpBuf.get(),dwReadSize,&NumberOfBytesRead,NULL)){
		//	?????????????s..
			Close();
			::CloseHandle(hFile); // ?????...
			return 4;
		}
		//	???k?t?@?C??
		CLZSS lzss;
		lzss.Decode(lpBuf.get(),*(BYTE**)&m_lpFileAdr,m_dwFileSize,false);	//	?G???[????????????H?H
	} else if (!::ReadFile(hFile,m_lpFileAdr,dwReadSize,&NumberOfBytesRead,NULL)){
		Close();
		::CloseHandle(hFile); // ?????...
		// Err.Out("CFile??t?@?C???????????s");
		return 4; // ?t?@?C????????????s?B
	}

	if (::CloseHandle(hFile)==false) {
		Close();
		// Err.Out("CFile??t?@?C????close????s");
		return 5; // Close????s?B?????????????...
	}

	if (*(DWORD*)m_lpFileAdr == 0x314B5059) {	//	HEADER:YPK1(yanepack1) == Data is Encoding...
		m_bEncode = true;
		for (DWORD i=4;i<m_dwFileSize;i++){
			//	?j?u?????????????:p
			*((BYTE*)m_lpFileAdr+i) =	(((*((BYTE*)m_lpFileAdr+i) & 0xf) << 4) +
										 ((*((BYTE*)m_lpFileAdr+i) &0xf0) >> 4)) ^ 0xcc;
		}
		m_lpFileMemPos = (LPCSTR)m_lpFileAdr + 4; // for ReadLine
	} else {
		m_bEncode = false;
		m_lpFileMemPos = (LPCSTR)m_lpFileAdr; // for ReadLine
	}

	return 0; // ??????????I??:)
}
#pragma warning(default:4701) // ?l????????????????????warning

LRESULT CFile::Write(const string& fileName,LPVOID lpMem,DWORD dwSize){

	string strTempName;
	strTempName = CFile::MakeFullName(fileName);
	HANDLE hFile = ::CreateFile(strTempName.c_str(),
		GENERIC_WRITE,		// Write
		0,					// 
		NULL,				// security
		TRUNCATE_EXISTING,
		FILE_ATTRIBUTE_NORMAL,	//	?t?@?C??????
		NULL				// ?e???v???[?g?t?@?C??
	);
	//	OPEN_ALWAYS???A?O??t?@?C???T?C?Y???c????????...

	if (hFile == INVALID_HANDLE_VALUE) { // ????????I
		hFile = ::CreateFile(strTempName.c_str(),
			GENERIC_WRITE,		// Write
			0,					// 
			NULL,				// security
			CREATE_NEW,
			FILE_ATTRIBUTE_NORMAL,	//	?t?@?C??????
			NULL				// ?e???v???[?g?t?@?C??
		);
		if (hFile == INVALID_HANDLE_VALUE) return 1; // Open???s		
	}

	DWORD NumberOfBytesRead = 0;
	if (!::WriteFile(hFile,lpMem,dwSize,&NumberOfBytesRead,NULL)){
		::CloseHandle(hFile); // ?????...
		// Err.Out("CFile::Write??t?@?C?????????????s");
		return 2;
	}

	if (!::CloseHandle(hFile)) {
		return 3; // Close????s?B?????????????...
	}

	return 0; // ??????????I??:)
}

const string	CFile::GetName() const {
	// ??????????t?@?C????????
	return m_strFileName;
}

void CFile::Reset(){
	m_lpFileMemPos = (LPCSTR)GetMemory();
}

//	UNICODE?????B??????Windows??e?L?X?g?t?@?C????p:p
LRESULT		CFile::ReadLine(LPSTR buf,DWORD dwSize){	 // ?o?b?t?@??dwSize?o?C?g?p??????????
	if (m_lpFileMemPos == NULL) return 3; // ??????????[?I?I
	if (m_lpFileMemPos >= (LPCSTR)m_lpFileAdr + m_dwFileSize) return 1;

	for(int i=0;i<(int)(dwSize-1);i++){
		if (*m_lpFileMemPos == 0x0D && *(m_lpFileMemPos+1) == 0x0A ||
			(m_lpFileMemPos >= (LPCSTR)m_lpFileAdr + m_dwFileSize)) { // CR+LF
			*buf = '\0'; // ??s?I???I
			m_lpFileMemPos+=2;
			return 0;
		}
		*(buf++) = *(m_lpFileMemPos++);
	}
	*buf = '\0';
	return 2;	// buffer over
}

LRESULT		CFile::ReadLine(string&s){
	// ???????A?o?b?t?@????O??p???????????B
	//	????l 0: ????I?? 1:EOF   3:?t?@?C????????????O?O?G
	if (m_lpFileMemPos == NULL) return 3; // ??????????[?I?I
	if (m_lpFileMemPos >= (LPCSTR)m_lpFileAdr + m_dwFileSize) return 1;
//	if (m_lpFileMemPos+1 >= (LPCSTR)m_lpFileAdr + m_dwFileSize) return 1;
				//	???P?c??'\0'?????????????A+1???K?v?

	DWORD dwSize = 0;
	while (true) {
		if (*m_lpFileMemPos == 0x0D && *(m_lpFileMemPos+1) == 0x0A ||
			(m_lpFileMemPos >= (LPCSTR)m_lpFileAdr + m_dwFileSize)) { // CR+LF
//			*buf = '\0'; // ??s?I???I
			//LPSTR psz = new CHAR[dwSize+1];
			//::CopyMemory(psz,m_lpFileMemPos-dwSize,dwSize);
			//*(psz+dwSize) = '\0';
			//s = psz;
			//delete [] psz;
			s.assign(m_lpFileMemPos-dwSize,dwSize);
			m_lpFileMemPos+=2;
			return 0;
		}
//		*(buf++) = *(m_lpFileMemPos++);
		++m_lpFileMemPos;
		++dwSize;
	}
	//	???????????..
	return 0;
}

LRESULT		CFile::ReadLine2(LPSTR Senario,DWORD dwSize){
	smart_ptr<CHAR> lpBuf;
	lpBuf.AddArray(dwSize);	//	???T?C?Y?m??

	if (lpBuf.isNull() || dwSize == 0) return 1;
	Senario[0] = '\0';
	if (ReadLine(lpBuf.get(), dwSize)!=0) return 1;
	if (!::lstrcmp(lpBuf.get(),"\"END\"")) return 1; // ?I????
	CHAR* pSrc = lpBuf.get() + 1;
	if (pSrc[0]) {
		::lstrcpyn(Senario, pSrc, (int)dwSize);
	}
	while (true) {
		size_t len = ::lstrlen(Senario);
		if (len == 0) break;
		if (Senario[len-1] == '\"') break;	//	?f???~?^:="
		if (ReadLine(lpBuf.get(), dwSize)!=0) return 1;
		if (len + 1 + ::lstrlen(lpBuf.get()) + 1 > (size_t)dwSize) return 2; // buffer over
		::lstrcat(Senario,"\n");
		::lstrcat(Senario,lpBuf.get());
	}
	size_t len = ::lstrlen(Senario);
	if (len > 0) Senario[len-1] = '\0';
	return 0;
}

LRESULT	CFile::ReadData(BYTE*p,DWORD size){
	if (m_lpFileMemPos == NULL) return 2; // ??????????[?I?I
	if (m_lpFileMemPos >= (LPCSTR)m_lpFileAdr + m_dwFileSize) return 1;

	::CopyMemory(p,m_lpFileMemPos,size);
	m_lpFileMemPos+=size;
	return 0;
}

//	?f?[?^?????^??????(CSerialize????p???????)
LRESULT		CFile::Load(const string& filename,vector<BYTE>*vData){
	LRESULT lr = Read(filename);
	if (lr!=0) return lr; // ????????s???????D?D?D
	//	???????t?@?C????????????A????S??vData??R?s??????I
	const int nSize = GetSize();
	vData->resize(nSize);
	::CopyMemory((LPVOID)&(*vData)[0],GetMemory(),nSize);
	return 0;
}

LRESULT		CFile::Save(const string& filename,vector<BYTE>*vData){
	return Write(filename,(LPVOID)&(*vData)[0],vData->size());
}

LRESULT		CFile::Save(const string& filename,vector<string>*vData){
	//	????Afopen?????????????????A????????????H
	const int nSize = vData->size();
	FILE *fp = fopen(filename.c_str(),"w");
	if (fp==NULL) return 1;

	for(int i=0;i<nSize;i++){
		if (fprintf(fp,(*vData)[i].c_str())<0) return 2;
		//	????????????????HDD??????????H
	}
	fclose(fp);
	return 0;
}

} // end of namespace Auxiliary
} // end of namespace yaneuraoGameSDK3rd
