#include "stdafx.h"
#include "../Thread/yaneThread.h"
#include "../AppFrame/yaneAppBase.h"
#include <process.h>

namespace yaneuraoGameSDK3rd {
namespace Thread {

//////////////////////////////////////////////////////////////////////////////
//	static members..
ThreadLocal<IThread*> IThread::pThread;

//////////////////////////////////////////////////////////////////////////////

CThread::CThread(){
	m_dwThreadHandle	 = (HANDLE)0;
	m_dwRunningThreadID	 = (DWORD)-1;
	//	-1??G???[?l?B(?X???b?h?n???h???????????????l)
	//	?i_beginthread????_???O?????????????????j

	m_bCreatedThread = false;
	m_nStackSize = 0; // default
}

CThread::~CThread(){
	StopThread();
}

//	?C?x???g?X?e?[?^?X???????
void	CThread::InitEvent(){
	GetExistEvent()->ResetEvent();	//	?m???V?O?i?????????
	//	?X???b?h??????????????????m???V?O?i?????

	GetThreadStarting()->ResetEvent();
	//	?X???b?h???J?n????????????????m???V?O?i?????

	GetExceptionEvent()->ResetEvent();	//	?m???V?O?i?????????
	//	??O???????????????????A?m???V?O?i?????

	GetThreadExecute()->ResetEvent();	//	?m???V?O?i?????????
	//	?X???b?h?????s??????????????A?m???V?O?i?????

	m_bCreatedThread = false;
	//	CreateThread??????????X???b?h????true
}

bool CThread::IsThreadValid()const{
	///	????????????????
	CThread* pThis = const_cast<CThread*>(this);
	return !pThis->GetExistEvent()->IsSignal();
}

bool CThread::IsThreadExecute()const /// ?X???b?h????s?????H
{
	CThread* pThis = const_cast<CThread*>(this);
	return pThis->GetThreadExecute()->IsSignal();
}

//////////////////////////////////////////////////////////////////////////////

LRESULT CThread::CreateThread(const smart_ptr<function_callback>& fn) {
	CCriticalLock cs(GetCriticalSection());
	m_fn = fn;
	return CreateThread();
}

void CThread::SetThreadFunction(const smart_ptr<function_callback>& fn){
	CCriticalLock cs(GetCriticalSection());
	m_fn = fn;
}

LRESULT CThread::CreateThread() {
	CCriticalLock cs(GetCriticalSection());

	StopThread();
	InitEvent();
	m_bCreatedThread = true;

//	return !::CreateThread(NULL,0,ThreadCallBack,this,NULL,&m_dwThreadHandle);
//	m_dwThreadHandle = ::_beginthread(0,ThreadCallBack,0,(void*)this);
	HANDLE dwThreadHandle =
		(HANDLE)::_beginthreadex(0,GetStackSize(),ThreadCallBack,(void*)this,0
			,(unsigned int*)&m_dwRunningThreadID);
	if (dwThreadHandle ==0 ){
	/*
					????????R???p?C???G???[???o????????A
		?????N?????C?u???????V???O???X???b?h??????????????B
		?v???W?F?N?g?????uC/C++?v??u?R?[?h?????v??A
		?u?g?p???????^?C?????C?u?????v??A
		?}???`?X???b?h?p???????g?p????????????B
	*/
		return -1;	//	?X???b?h?N??????s
	}
	m_dwThreadHandle = dwThreadHandle;

	/**
		?X???b?h???N??????????H
	*/
	return GetThreadStarting()->Wait();
		//	??_beginthreadex??A?G???[???A-1??????????
	/*
		CreateThread?????_beginthread??X???b?h???????????A
		C?????????^?C???????o?????????A???K???????????[?N??????????B
		(80?o?C?g???x)
		????A?R???p?C??????????A?}???`?X???b?h?p????C?u??????
		?????N??????????????????B

	????A

   Thread.c?t?@?C????`???????A
1. _beginthread ???? CreateThread ??A?????? ResumeThread
   ???R?[??????B
2. ?????A_threadstart ???R?[???????B
3. _threadstart????R?[???o?b?N??????R?[???????B
4. ??L?R?[???o?b?N????I????A??????
		_endthread ???R?[??
?@?@?????B

?@????A?X???b?h?n???h????????????B
?@??????????AWaitForSingleObject???????X???b?h??
?R?[???o?b?N??????I?????????A??????X???b?h?n???h??
??????@?????????B

	?????A_beginthreadex??????

	*/
}

LRESULT CThread::StopThread() {
	CCriticalLock cs(GetCriticalSection());

	InvalidateThread();			//	?~?????~???????I

	if (m_dwThreadHandle==(HANDLE)0) {
		return 0;
		//	?X???b?h??????????????H
	}

	//	????X???b?h?A???????g????????A???????????????X???b?h??I??????????????
	//	?f?b?h???b?N??????
	if (GetThreadId() == ::GetCurrentThreadId()) return 2;

	//	?????I??A????X???b?h????????R?[?h???????????????

	DWORD dwResult = 0;
	HANDLE dwThreadHandle = m_dwThreadHandle;
	m_dwThreadHandle = (HANDLE)0;
	m_dwRunningThreadID = (DWORD)-1;
	//	????????n???h?????R?s?[????A?N???A????????????ALeave?????r?[??
	//	??????X???b?h??Create?????A?n???h?????????????????
	//	??\????????

	if (m_bCreatedThread){
		cs.Leave();
			//?@????lock??????????????????A???[?J?[?X???b?h??Lock???l?????????
			//	dead lock???????
		dwResult = ::WaitForSingleObject(dwThreadHandle,INFINITE);
		cs.Enter();
	}
	//	?????????????A???S??R?[?h?????A?f?b?h???b?N??????
	//	(?R????????????????H?H??_beginthread ?B_beginthreadex???ok)
	//	???@_beginthread??????A?????I??X???b?h?n???h???????????

	if (dwResult != WAIT_OBJECT_0) {
		//	??????A????X???b?h?n???h??????L?????????
		//	?j???????????????v??..?????C??????????
		return 1;
	}
	::CloseHandle(dwThreadHandle);
	// ????n???h???????I????????\?[?X????????????

	//	?I?????????D?D
	return 0;
}

LRESULT CThread::JumpToThread() {
	StopThread();
	InitEvent();

	m_bCreatedThread = false;

	m_dwRunningThreadID = ::GetCurrentThreadId();
	//	?X???b?hID????
	//	(???????A?X???b?h?n???h???????????????????????????????D?D)

	{
		//	???X???b?h?}?l?[?W????o?^???????
		CThreadManager::GetObj()->AddThread(this);
		GetThreadExecute()->SetEvent();

		ThreadProc();				//	????????s????????

		GetThreadExecute()->ResetEvent();
		//	?X???b?h?}?l?[?W???????????
		CThreadManager::GetObj()->DelThread(this);

	}

	m_dwRunningThreadID = (DWORD)-1;	//	?X???b?h?I?????????
	return 0;
}

//void CThread::ThreadCallBack(LPVOID lpVoid){
unsigned __stdcall CThread::ThreadCallBack( void * lpVoid){
	//	??_beginthreadex??p???????X???????

	CThread* pCurrentThread = reinterpret_cast<CThread*>(lpVoid);

	pCurrentThread->m_dwRunningThreadID = ::GetCurrentThreadId();
	//	?X???b?hID????

	//	?X???b?h?}?l?[?W????o?^???????
	CThreadManager::GetObj()->AddThread(pCurrentThread);

	//	????t???O???????p????????????????????
	const smart_ptr<function_callback> fn(pCurrentThread->GetCallBack());
	pCurrentThread->GetThreadExecute()->SetEvent();
		//	??????t???O??????????A????X???b?h?????????X???b?h??
		//	CreateThread????????A???????SetFunction??CallBack?????
		//	????????????????????A??????????????????
	pCurrentThread->GetThreadStarting()->SetEvent();

	IThread::setThread(pCurrentThread);	//	?X???b?h?????????

	if (fn.isNull()){
		pCurrentThread->ThreadProc();
	} else {
		fn->run();	//	?R?[???o?b?N????
		pCurrentThread->m_fn.Delete();			//	function_callback????????
	}

	IThread::unsetThread();		//	???????????X???b?h*????

	/**
		Thread??O??????Invalidate????A
		????X???b?h??????wait???????X???b?h???m??????
	*/
	pCurrentThread->InvalidateThread();

	//	?X???b?h?}?l?[?W???????????
	CThreadManager::GetObj()->DelThread(pCurrentThread);
		//	DeleteThread???????StopThread?????

	return 0;
}

void	CThread::InvalidateThread(){
	CCriticalLock cs(GetCriticalSection());
	{
		CCriticalLock cl(GetLockObject()->GetCriticalSection());

		//	??????X?g??????????z???A?????????
		GetLockObject()->notifyThreadInWaitList(GetThreadId());

		//	?????I?u?W?F?N?g???V?O?i???????????
		GetExistEvent()->SetEvent();		//	????????
//		GetThreadExecute()->ResetEvent();	//	???s?????????
	}
}

//////////////////////////////////////////////////////////////////////////////
//	Java???Thread?@?\???A?y????????D?D

LRESULT	CThread::wait(int nTimeOut /*=-1*/)
		#ifdef USE_EXCEPTION
			throw(CInterruptedException)
		#endif
{
	///		wait ?L???[?????
	if (interrupted()){
		#ifdef USE_EXCEPTION
			throw CInterruptedException();
		#endif
	}
	LRESULT lr = GetLockObject()->wait(nTimeOut);
	/*	//	?????S?z??????CLockObject?????????
	if (interrupted()){
		#ifdef USE_EXCEPTION
			throw CInterruptedException();
		#endif
	}
	*/
	return lr;
}

LRESULT CThread::sleep(int nTime)
		#ifdef USE_EXCEPTION
			throw(CInterruptedException)
		#endif
{
	//	nTime [ms]???B????????????A?????I?u?W?F?N?g???V?O?i?????
	//	?i?X???b?h???I????????????A????????j?????A??0?????B

	if (interrupted()){
		#ifdef USE_EXCEPTION
			throw CInterruptedException();
		#endif
	}

	const HANDLE h[] = {
		//	??O?C?x???g??????C?x???g???????????????K?v??????
		GetExistEvent()->GetHandle(),
		GetExceptionEvent()->GetHandle()
	};

	DWORD dwResult =
		::WaitForMultipleObjects(
			2,&h[0],FALSE,nTime
		);

	if (interrupted()){
		#ifdef USE_EXCEPTION
			throw CInterruptedException();
		#endif
	}
	return dwResult == WAIT_TIMEOUT ? 0:1;
}

void	CThread::notify(){
	/// wait?????????X???b?h??@???N????(1????)
	GetLockObject()->notify();
}

void	CThread::notifyAll(){
	/// wait?????????????X???b?h??@???N????
	GetLockObject()->notifyAll();
}

void	CThread::interrupt(){
	/**
		?????????????B????????A???X???b?h??????o???B
		?????????A????X???b?h??A????wait??sleep??
			CInterruptedException??O??????????B
	*/
	CCriticalLock cl(GetLockObject()->GetCriticalSection());
	GetLockObject()->eraseThreadInWaitList(GetThreadId());
		//	???????????A??????????????
	GetExceptionEvent()->SetEvent();
	//	sleep????????\??????????A??????L?????????

}

bool	CThread::isInterrupted() const{
	///	????????????????
	CThread* pThis = const_cast<CThread*>(this);
	return pThis->GetExceptionEvent()->IsSignal();
}

bool	CThread::interrupted() {
	///	???????????????????????A?????A
	///	???????????Z?b?g????B
	CCriticalLock cl(GetLockObject()->GetCriticalSection());
		//	??Lock??????????B

	bool bInterrupted = GetExceptionEvent()->IsSignal();
	GetExceptionEvent()->ResetEvent();
	return bInterrupted;
}

//////////////////////////////////////////////////////////////////////////////
//	ThreadManager
//////////////////////////////////////////////////////////////////////////////
singleton<CThreadManager> CThreadManager::m_obj;

void	CThreadManager::AddThread(IThread* pThread){
	CCriticalLock cl(GetLockObject()->GetCriticalSection());
	//	?d???o?^???S?z?????????????
	GetThreadList()->push_back(pThread);
	GetLockObject()->notifyAll();
}

void	CThreadManager::DelThread(IThread* pThread){
	CCriticalLock cl(GetLockObject()->GetCriticalSection());

	{
		threadlist::iterator it =
			find(GetThreadList()->begin(),GetThreadList()->end(),pThread);
		if (it!=GetThreadList()->end()){
		//	????????????????????????D?D
			GetThreadList()->erase(it);
		}
	}

	//	???????A?????????L?????????????X???b?h???I??????????A
	//	?????erase???????
	{
		smart_list_ptr<CThreadList>::iterator it =
			GetMyThreadList()->begin();
		while (it!=GetMyThreadList()->end()){
			if ((*it)->pThread.get() == pThread){
			//	?????????????????????????D?D
//				it = GetMyThreadList()->erase(it);
				//	??????X???b?h?????????????????o?????
				(*it)->bValid = false; // delete?}?[?N???????
				it++;
			} else {
				it++;
			}
		}
	}

	GetLockObject()->notifyAll();
}

bool	CThreadManager::StopAllThread() {
	if (isStopAllThread()) return false;
	/*
		?S?X???b?h???~???????????o?????????A
		????X???b?h????~?????????????A
		?????~???????o???????X???b?h???~?????????
		?o????????A?f?b?h???b?N????B
		?????A???????Abalk?????
	*/

	CCriticalLock cl(GetLockObject()->GetCriticalSection());

	GarbageThread();	//	?K?[?x?W????????A?????I????????????m????

			//	?????????g??X???b?h???????????????A1??????????????
	while (!(
				(
					(GetThreadList()->empty())
				||
					(
						(GetThreadList()->size()==1)
					&&
						((*GetThreadList()->begin())->GetThreadId()
							==GetCurrentThreadId())
					)
				)
			&&
			//	??????????X???b?h?????????A?P??????????????A????????X???b?h???g?????
				(
					(GetMyThreadList()->empty())
				||
					(
						(GetMyThreadList()->size()==1)
					&&
						((*GetMyThreadList()->begin())->pThread->GetThreadId()
							==GetCurrentThreadId())
					)
				)
			)){

				/** /	//	debug?p?e?X?g?R?[?h
				int n1 = GetThreadList()->size();
				int n2 = GetMyThreadList()->size();
				DWORD n3 = (*GetThreadList()->begin())->GetThreadId();
				DWORD n4 = (*GetMyThreadList()->begin())->pThread->GetThreadId();
				DWORD n5 = GetCurrentThreadId();
				//*/

	///	GetMyThreadList??A????????s????????X???b?h???????
	///	?v?????AGetThreadList????????X???b?h??????empty?????????????
	///	GetMyThreadList??empty???????A?I?????????????????????????
	//	?S?X???b?h???~?????????
		threadlist::iterator it = GetThreadList()->begin();
		while (it!=GetThreadList()->end()){
//			(*it)->StopThread();
			/**
				????X???b?h??????X???b?h???~??????????A
				????X???b?h???I??????????A??L??X???b?h???X?g????
				???????????????????A????????L?`?F?C????
				critical lock???????????????A??????f?b?h???b?N????B
			*/
			(*it)->InvalidateThread();	//	?????????H
			it++;
		}
		//	??????????s???????A
		//	?V????X???b?h??????????\????????
		GetLockObject()->wait();
		GarbageThread();
	}
	return true;
}

//	??????X???b?h???I??????????
void	CThreadManager::WaitAllThreadEnded() {
	CCriticalLock cl(GetLockObject()->GetCriticalSection());

	GarbageThread();	//	?K?[?x?W????????A?????I????????????m????
	while (!(GetThreadList()->empty() && GetMyThreadList()->empty())){
	///	GetMyThreadList??A????????s????????X???b?h???????
	///	?v?????AGetThreadList????????X???b?h??????empty?????????????
	///	GetMyThreadList??empty???????A?I?????????????????????????
		GetLockObject()->wait();
		//	????wait?????o????busy wait???????
		GarbageThread();
	}
}

void	CThreadManager::_RegistThread(
	const shared_ptr<IThread>& pThread,
	const shared_obj&	obj/*=NULL*/
){
	CCriticalLock cl(GetLockObject()->GetCriticalSection());
	CThreadList* p = new CThreadList;
	p->pThread	= pThread;
	p->obj = obj;
	GetMyThreadList()->push_back(smart_ptr<CThreadList>(p));
}

void	CThreadManager::GarbageThread(){
	//	lock????????????A?O????lock????????
	//	???????A?????????L?????????????X???b?h???I??????????A
	//	?????erase???????
	{
		smart_list_ptr<CThreadList>::iterator it =
			GetMyThreadList()->begin();
		while (it!=GetMyThreadList()->end()){
			if (!(*it)->bValid){
			//	delete?}?[?N?????????????
				it = GetMyThreadList()->erase(it);
			} else {
				it++;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////

///	RunThread?????ACAppFrame??Run?????o????????????
LRESULT CThreadManager::RunThread(IAppBase*pAppBase){
	return RunThread(shared_ptr<IAppBase>(pAppBase));
}

LRESULT CThreadManager::RunThread(const shared_ptr<IAppBase>& pAppBase){
	shared_ptr<IAppBase>* p = new shared_ptr<IAppBase>(pAppBase);

	shared_ptr<IThread> pThread(pAppBase->GetWorkerThread(),false);
		//	??????X???b?h???~???A????I?u?W?F?N?g????t?F?C?Y?????

	GetObj()->_RegistThread(pThread,shared_obj(p));
	//	smart_ptr_base??L???X?g?????

	return pAppBase->Run();	//	?????????s????
}

///	CreateThread?????AIThread??CreateThread?????o????????????
LRESULT CThreadManager::CreateThread(IThread*pThread){
	return CreateThread(shared_ptr<IThread>(pThread));
}

LRESULT CThreadManager::CreateThread(const shared_ptr<IThread>& pThread){
	RegistThread(pThread);
	return pThread->CreateThread();	//	?X???b?h???
}

} // end of namespace Thread
} // end of namespace yaneuraoGameSDK3rd
