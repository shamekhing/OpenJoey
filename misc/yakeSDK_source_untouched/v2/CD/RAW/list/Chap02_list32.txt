
CDllPlugInLoader::CDllPlugInLoader(){
	m_hDll = NULL;
}
CDllPlugInLoader::~CDllPlugInLoader(){
	Release();
}

LRESULT CDllPlugInLoader::Load(const string& szDllName){
	m_strFileName = szDllName;
	// DLLを読み込む
	m_hDll = ::LoadLibrary(m_strFileName.c_str());
	if(m_hDll==NULL){
		Err.Out("CDllPlugInLoader::Load \"(null)\"のロードに失敗", m_strFileName.c_str());
		return 1;
	}
	return 0;
}

LRESULT CDllPlugInLoader::Release(){
	LRESULT lr=0;
	if(m_hDll!=NULL){
		lr = !::FreeLibrary(m_hDll);
		m_hDll = NULL;
	}
	return lr;
}

//////////////////////////////////////////////////////////////////////////////

//	static member..
singleton<CObjectCreater> CObjectCreater::m_vObj;

CObjectCreater::CObjectCreater(): m_pPlugInInfo(0){}

void* CObjectCreater::Create(const string& strClassName){
	void* pObj=NULL;
	CCriticalLock cl(GetCriticalSection());
	{
		smart_vector_ptr<CObjectInfo>& info = *GetObjectInfo();
		smart_vector_ptr<CObjectInfo>::iterator it = info.begin();
		while (it!=info.end()){
			if (strClassName==(*it)->strClassName){
			//	こいつやー！！
			//	こいつのfactory呼び出してオブジェクト作って返したるで！！
				//if (it->factory_base!=NULL){
				//	↑これNULLであることはありえない
					pObj = (*it)->factory->Create();
					break;
				//}
			}
			it++;
		}
	}
	return pObj;
}

LRESULT CObjectCreater::LoadPlugIn(const string& strFileName){
	LRESULT lr=0;
	string str(CFile::MakeFullName(strFileName));
	//	これ、MakeFullNameより、FindFileのほうが良いのだが...

	CCriticalLock cl(GetCriticalSection());
		//	同名のplug inを探す
		smart_vector_ptr<CPlugInInfo>::iterator	it = FindPlugIn(str);
		if (it == GetPlugInInfo()->end()) {
			//	読み込んで、そのクラス（のfactory）を登録する
			m_pPlugInInfo = new CPlugInInfo;
			//	この変数は、DLL側から参照されうる
			if (m_pPlugInInfo->vPlugIn.Load(str)==0){	
			//	plug-in読み込みに成功
				HINSTANCE hDll = m_pPlugInInfo->vPlugIn.GetInstance();
				typedef void (_cdecl *Func)(void*);
				Func YaneDllInitializer = (Func)::GetProcAddress(hDll, "YaneDllInitializer");
				if(YaneDllInitializer==NULL){
					//	初期化失敗ゴン
					DELETE_SAFE(m_pPlugInInfo);
				} else {
					//	所有権の移動
					YaneDllInitializer(static_cast<void*>(this));
					GetPlugInInfo()->insert(m_pPlugInInfo);
					m_pPlugInInfo = NULL;	//	deleteしてはいかん
				}
			} else {
				DELETE_SAFE(m_pPlugInInfo);
			}
		} else {
			//	既に読み込んでいるので、その参照カウントのみを加算する
			(*it)->nRef++;
		}
	return lr;
}

LRESULT CObjectCreater::ReleasePlugIn(const string& strFileName){
	LRESULT lr=0;

	string str(CFile::MakeFullName(strFileName));
	//	これ、MakeFullNameより、FindFileのほうが良いのだが...

	CCriticalLock cl(GetCriticalSection());
		//	同名のplug inを探す
		smart_vector_ptr<CPlugInInfo>::iterator	it = FindPlugIn(str);
		if (it == GetPlugInInfo()->end()) {
			//	無いとは、どういうこっちゃ？
			Err.Out("CObjectCreater::ReleasePlugIn 登録されていないPlugInの削除");
		} else {
			//	参照カウントを減算する
			if (--(*it)->nRef == 0){
				//	0になったので、このオブジェクトをdelete	する
				CPlugInInfo* pInfo = (*it).get();
				GetPlugInInfo()->erase(it);	//	smart_ptrなので、これで消せる
				//	このpInfoを用いているオブジェクトの
				//	factoryを登録抹消しなければならない
				smart_vector_ptr<CObjectInfo>::iterator it2
					= GetObjectInfo()->begin();
				while (it2!=GetObjectInfo()->end()){
					if ((*it2)->pPlugIn == pInfo){
						it2 = GetObjectInfo()->erase(it2);
					} else {
						it2++;
					}
				}
			}
		}
	return lr;
}

smart_vector_ptr<CObjectCreater::CPlugInInfo>::iterator
	CObjectCreater::FindPlugIn(const string& strPlugInName){
/*
	この関数は、
		LRESULT CObjectCreater::LoadPlugIn と ReleasePlugIn
	から呼び出されるので、CriticalSection中であると仮定して良い
*/
	smart_vector_ptr<CPlugInInfo>::iterator	it = GetPlugInInfo()->begin();
	while (it!=GetPlugInInfo()->end()){
		if (strPlugInName == (*it)->vPlugIn.GetFileName())
			break;
		it++;
	}
	return it;
}

void CObjectCreater::RegistClass(const string& strClassName,factory_base*f){
	CObjectInfo* pInfo = new CObjectInfo;
	pInfo->pPlugIn		= m_pPlugInInfo;
	pInfo->strClassName = strClassName;
	pInfo->factory		= f;
	GetObjectInfo()->insert(pInfo);
}


void* CObjectCreater::New (size_t t){
	return new BYTE[t];
}

void  CObjectCreater::Delete(void* p){
	delete [] p;
}
