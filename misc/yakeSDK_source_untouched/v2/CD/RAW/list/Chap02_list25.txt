
class function_callback {
/**
	関数のコールバック用基底クラス
	こいつの、smart_ptrを相手に渡して、
	相手からは、run()を呼び出してもらえればそれで良い

	例)
		smart_ptr<function_callback_r>
			s(function_callback_r<int>::Create(&test,1,10));
		//	コールバックオブジェクトが完成
		int nResult = s->run();
		//	int test(int n1,int n2)という関数をtest(1,10)と呼び出す

		function_callback_rg2のrg2とは、
			r : result有り	vならばresult無し
			g : グローバルな関数 mならばmember関数
			2 : 関数の引数は２つ
		の意味です。

		引数は5つのテンプレートまで用意してあります。
		それ以上については、自前で用意してください。

		例：
		smart_ptr<function_callback_v>
			s(function_callback_v::Create(&CHoge::test,this,1,10));
		//	コールバックオブジェクトが完成
		s->run();
		//	void CHoge::test(int n1,int n2)という関数をtest(1,10)と呼び出す

		function_callback_vもfunction_callback_rも、
		このfunction_callback派生クラスなので、戻り値はどうでも良いのならば
		受け取るのは、smart_ptr<function_callback>でも構いません。

		void test(int n)という関数をtest(m)とコールバックするならば、
		smart_ptr<function_callback> f(function_callback_v::Create(test,m));
		f->run();

		//	int CHoge::test(int n1,int n2,int n3)という関数をtest(1,10,100)と呼び出す
		smart_ptr<function_callback_r<int> >
			s(function_callback_r<int>::Create(CHoge::test,this,1,10,100));
		s->run();
		int r = s->GetResult();	//	これで返し値を取得

		//	グローバルな関数int	SukiSukiSakura(int n1,int n2)を呼び出す場合
		smart_ptr<function_callback_r<int> >
			s(function_callback_r<int>::Create(&SukiSukiSakura,2,3));
		s->run();
		int r = s->GetResult();	//	これで返し値を取得

*/
public:
	virtual	void run() = 0;
	virtual ~function_callback(){}
};

class function_callback_v : public function_callback {
///		返し値を持たないバージョン
public:
	//	ヘルパ関数
	static function_callback_v* Create(void (*f)());

	template <class Arg1,class T>
		static function_callback_v* Create(void (T::*f)(Arg1),const Arg1& a1){
			return new function_callback_vg1<Arg1>(f,a1);
	}
	template <class Arg1>
	static function_callback_v* Create(void (*f)(Arg1),const Arg1& a1){
			return new function_callback_vg1<Arg1>(f,a1);
	}
	template <class Arg1,class Arg2>
	static function_callback_v* Create(void (*f)(Arg1,Arg2),const Arg1& a1,const Arg2& a2){
			return new function_callback_vg2<Arg1,Arg2>(f,a1,a2);
	}

	//			<B>中略</B>

	template <class obj>
	static function_callback_v* Create(void (obj::*f)(),obj* o){
			return new function_callback_vm0<obj>(f,o);
	}
	template <class obj,class Arg1>
	static function_callback_v* Create(void (obj::*f)(Arg1),obj* o,const Arg1& a1){
			return new function_callback_vm1<obj,Arg1>(f,o,a1);
	}
	template <class obj,class Arg1,class Arg2>
	static function_callback_v* Create(void (obj::*f)(Arg1,Arg2),obj* o,
		const Arg1& a1,const Arg2& a2){
			return new function_callback_vm2<obj,Arg1,Arg2>(f,o,a1,a2);
	}

	//			<B>中略</B>
};

template <class Result>
class function_callback_r : public function_callback {
///		返し値をテンプレート化されたバージョン
public:
	Result GetResult() const { return _r; }

	//	ヘルパ関数
	static function_callback_r* Create(Result (*f)());
	template <class Arg1>
	static function_callback_r* Create(Result (*f)(Arg1),const Arg1& a1){
			return new function_callback_rg1<Result,Arg1>(f,a1);
	}
	template <class Arg1,class Arg2>
	static function_callback_r* Create(Result (*f)(Arg1,Arg2),
		const Arg1& a1,const Arg2& a2){
			return new function_callback_rg2<Result,Arg1,Arg2>(f,a1,a2);
	}

	//			<B>中略</B>

	template <class obj>
	static function_callback_r* Create(Result (obj::*f)(),obj* o){
			return new function_callback_rm0<Result,obj>(f,o);
	}
	template <class obj,class Arg1>
	static function_callback_r* Create(Result (obj::*f)(Arg1),obj* o,const Arg1& a1){
			return new function_callback_rm1<Result,obj,Arg1>(f,o,a1);
	}
	template <class obj,class Arg1,class Arg2>
	static function_callback_r* Create(Result (obj::*f)(Arg1,Arg2),obj* o,
		const Arg1& a1,const Arg2& a2){
			return new function_callback_rm2<Result,obj,Arg1,Arg2>(f,o,a1,a2);
	}

	//			<B>中略</B>

protected:
	Result _r;
};
