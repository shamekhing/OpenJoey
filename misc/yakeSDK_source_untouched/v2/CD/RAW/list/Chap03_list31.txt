CLoadCache::CLoadCache() :
	m_vLoadCacheListener(new ILoadCacheListener),
	m_bCanReloadAgain(true),
	m_nCacheMax(INT_MAX)
{}

LRESULT		CLoadCache::Load(int nNo){

	if (nNo<0 || GetSize()<=nNo) return -1;
	//	範囲外

	CLoadCacheInfo &info = *GetLoadCache(nNo);

	InnerUse(nNo);	//	こいつを参照しました！

	if (info.bLoaded) {
		//	既に読み込んどるでー
		return 0;
	}

	//	読み込みに失敗しようがフラグは立てておかないと、
	//	あとで解放しようとしたときに不正なアクセスになる
	info.bLoaded = true;

	//	読み込んだことによって、キャッシュオーバーした分を解放
	InnerPushOut();

	return InnerLoad(nNo);
}

void	CLoadCache::InnerUse(int nNo){
/**
	-1でないときのインクリメント
前		1 2 3 -1 4 -1 5 0
後	⇒	2 3 0 -1 4 -1 5 1
			↑を使用したので、こいつを0に

  -1からのインクリメント
前		1 2 3 -1 4 -1 5 0
後	⇒	2 3 4  0 4 -1 6 1
			  ↑を使用したので、こいつを0に
*/

	int nSize = GetSize();
	CLoadCacheInfo &info = *GetLoadCache(nNo);
	int nStaleTime = info.nStaleTime;
	if (nStaleTime == -1) nStaleTime = INT_MAX;
	for (int i=0;i<nSize;i++){
		//	使用カウンタのインクリメント
		CLoadCacheInfo &info2 = *GetLoadCache(nNo);
		if (info2.nStaleTime < nStaleTime && info2.nStaleTime!=-1){
			//	これより低いやつのみ
			info2.nStaleTime++;
		}
	}
	info.nStaleTime = 0;
}

void	CLoadCache::SetCacheMax(int nCacheMax){
	m_nCacheMax = nCacheMax;
	InnerPushOut();
}

void	CLoadCache::InnerPushOut(){
	int nSize = GetSize();
	for (int i=0;i<nSize;i++){
		CLoadCacheInfo &info = *GetLoadCache(i);
		if (info.nStaleTime >= m_nCacheMax) {
		//	これよりカウンタの進んだ奴は解放
			Release(i);
		}
	}
}
