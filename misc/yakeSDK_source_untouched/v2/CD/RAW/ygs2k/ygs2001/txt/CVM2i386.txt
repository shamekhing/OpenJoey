
class CVM2i386
		仮想CPUコードをi386ネイティブコードに変換する

	概要 :
		これは、スクリプトで生成された仮想マシンコードを、
		i386ネイティブコードに変換することによって、高速化を
		計るためのものです。

		変換は、テーブルのルックアップによって、仮想マシンコード
		１命令に対して一群のi386の命令が１対１に対応し、
		それを機械的に置換するだけの作業を行なっています。

		よって、最適化等は甘いと言わざるを得ないですが、それでも
		仮想マシンコードを実行するより５倍〜１０倍は速いはずです。


	file : yaneCVM2i386.h , yaneCVM2i386.cpp　, yaneVM2i386table.h


	利用法 :

	1.仮想CPU用の実行コードを作成する

	2.CVM2i386::Convertを呼び出す
		CVM2i386のコンストラクタは、m_PC,m_SP,m_ReturnNumの入っている
			アドレスをDWORDにキャストして渡す。
		※　ただし、スタックは逆積みなのでpush/popの方向と、m_SPの初期値に
			気をつけること。

		lpCodeには、仮想CPUコードの入っているアドレス
		dwSizeには仮想CPUコードの入っているメモリサイズを入れる。
		（データエリアのサイズを含めてはいけない）

		備考：i386系のスタック動作は、
			PUSH(x) { *(--sp) = x; }
			POP (x) { x = *(sp++); }
		であり、仮想マシンのスタック動作は、
			PUSH(x) { *(sp++) = x; }
			POP (x) { x = *(--sp); }
		である。


	3.すると、仮想CPUコードに対応するi386ネイティブコードがどこかに
	生成される。それらのメモリはVirtualProtectで実行属性になっている
	ので実行可能である。

	4.lpCode〜dwSize分のメモリ上に存在する仮想マシンの命令コードは、
		i386ネイティブコードへのジャンプアドレスに変化している。

		たとえば、本来ならば、lpCodeから実行していたのであれば、
		*lpCodeを直接呼び出すことによって、ネイティブコードを実行する
		ことが出来る。

	5.よって、従来、仮想CPUコードが存在していたアドレスを
		m_PCが指すようにして、

		CVM2i386::Execute()

		を呼び出すことによって対応するネイティブコードに自動的に
		ジャンプして実行される。

	6.内部的に確保されたメモリの解放等は、デストラクタが勝手にやって
		くれる

		CVM2i386::Free()

		を呼び出して明示的に行なうことも可能である。


CScriptCompilerで実際に使用しているので、そちらを参照すると良い。

