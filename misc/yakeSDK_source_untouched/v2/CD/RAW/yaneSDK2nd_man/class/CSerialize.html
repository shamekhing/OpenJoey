<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META name="GENERATOR" content="IBM HomePage Builder 2001 V5.0.0 for Windows">
<TITLE>class CSerialize</TITLE>
</HEAD><BODY bgcolor="#ccffcc" text="#336633" link="#0066cc" vlink="#009999" alink="#ff9900">
<P><FONT size="+2">class CSerialize</FONT><A name="CTimeBase"></A>　<FONT color="#ff0000">【コンポーネント<FONT color="#ff0000">】</FONT></FONT></P>
<HR>
<P><FONT size="+1" color="#009900">☆　内容</FONT></P>
<P>シリアライズ（データ永続化）のため手段。メンバ変数・配列などを、ストリームにつっこみ、あるいは取り出して、それをファイルに保存／復元することで、アプリケーションが終了したあとも、前回の状態を保つことが出来る。</P>
<P><FONT size="+1" color="#009900">☆　解説</FONT></P>
<P>１．保存するとき<BR>
　CSerialize s;<BR>
　CArchive派生クラス v;<BR>
　s &lt;&lt; v; // これで格納<BR>
　vector&lt;BYTE&gt;&amp; vData = *(s.GetData());<BR>
　↑あとは、こいつを、&amp;vData[0]から、vData.size()バイトだけ<BR>
　ファイルとして保存すれば、シリアライズ完了。</P>
<P>２．シリアライズしたデータを読み出すとき<BR>
　CSerialize s;<BR>
　CArchive派生クラス v;<BR>
　vector&lt;BYTE&gt;&amp; vData = *(s.GetData());<BR>
　vDataに１．でシリアライズしたファイルから読み込む。<BR>
　s.SetStoring(false); // いまから読み出すねん！<BR>
　// ↑このフラグさえ、このようにストリームからの読み出しであると<BR>
　// 宣言さえすれば、<BR>
　s &lt;&lt; v; // これ、１．と同じ表記でＯＫ。<BR>
　これで、ストリームからの読み出しが完了。</P>
<P>３．上の手順でCArchive派生クラスを使わないとき保存）</P>
<P>　CSerialize s;<BR>
　int x,y,z;<BR>
　s &lt;&lt; x &lt;&lt; y &lt;&lt; z;<BR>
　CSerialize s;<BR>
　s.SetStoring(false); // このフラグを倒しておけば取り出し<BR>
　int x,y,z;<BR>
　s &lt;&lt; x &lt;&lt; y &lt;&lt; z;</P>
<P>　例１．<BR>
　int x = 1,y = 2,z = 3;<BR>
　CSerialize s;<BR>
　string sz;<BR>
　sz = &quot;あいうえお&quot;;<BR>
　s &lt;&lt; sz;<BR>
　s &lt;&lt; x &lt;&lt; y &lt;&lt; z; //
ストリームに保存</P>
<P>　CFile file;<BR>
　file.Save(&quot;test.dat&quot;,s.GetData());
// 保存してみよう＾＾；<BR>
　file.Load(&quot;test.dat&quot;,s.GetData());
// 読み込んでみよう＾＾；</P>
<P>// ↑ s.Save(&quot;test.dat&quot;);<BR>
// s.Load(&quot;test.dat&quot;); でも同じ意味</P>
<P>　s.SetStoring(false); // ストリームから獲得<BR>
　string sy;<BR>
　s &lt;&lt; sy; // syには、あいうえおが返ってくる<BR>
　s &lt;&lt; z &lt;&lt; y &lt;&lt; x; //
z,y,zには、それぞれ1,2,3が返ってくる</P>
<P>注意点：</P>
<P>CSerialize x,y,z;<BR>
　x &lt;&lt; y &lt;&lt; z;を<BR>
　x.SetStoring(false); // このフラグを倒しておけば取り出し<BR>
　x &lt;&lt; y &lt;&lt; z;と復元できる。これは、CSerializeの保持している<BR>
　アーカイブは、vector&lt;BYTE&gt;であり、vectorの書き出し時には、<BR>
　そのサイズvector::size() を先頭にintデータとして書き出してあるためである。よって、</P>
<P>　CSerialize x,y;<BR>
　int a,b;<BR>
　y &lt;&lt; a &lt;&lt; b; // yにa,bをシリアライズ<BR>
　x &lt;&lt; y; // xにyをシリアライズ<BR>
とした場合、<BR>
　x.SetStoring(false); // このフラグを倒しておけば取り出し<BR>
　x &lt;&lt; a &lt;&lt; b;<BR>
では正しく取り出せない。なぜならば、先頭にyのアーカイブサイズが混入しているからである。これを取り除くために、ダミーでintの値を取り出してやると良い。</P>
<P>　int dummy;<BR>
　x &lt;&lt; dummy &lt;&lt; a &lt;&lt; b;</P>
<P>配列に対しても正しくシリアライズできる<BR>
　例<BR>
　int n[5];<BR>
　CSerialize x;<BR>
　x.Store(&amp;n[0],NELEMS(n));<BR>
この部分を、さらにマクロを利用して、</P>
<P>x.Store(ArraySerialize(n));と書ける<BR>
（ただし、以下のマクロによる実装なので配列サイズがわかっているときのみ）</P>
<P>#define ArraySerialize(n) &amp;n[0],NELEMS(n)</P>
<P>たとえば、stringに対しても同じように<BR>
　string s[5];<BR>
　CSerialize x;<BR>
　x.Store(ArraySerialize(s));と書ける。</P>
<P>また、CArchive派生クラスに対しても同様に<BR>
　CArchiveDerived ar[5];<BR>
　CSerialize x;<BR>
　x.Store(ArraySerialize(ar));と書けます。</P>
<P><FONT size="+1" color="#009900">☆　メンバ関数</FONT></P>
<P>// データの初期化。<BR>
// 内部のストリームをクリアして、IsStoring()はtrueを返すようになる<BR>
void Clear( );</P>
<P>bool IsStoring( );<BR>
void SetStoring(bool b);</P>
<P>//　　↑これをfalseを設定して、取得（復元）方向にしたとき、<BR>
//　　データのどこから読み出しているかを示すデータポジションポインタもクリア(0に設定)される<BR>
//　　もし、それが許せないのであれば、↓この関数を使えば良い。</P>
<P>void InnerSetStoring(bool b);<BR>
// データポジションのリセット・データクリア等を行なわずに格納方向だけ<BR>
// 変更するならば、こっちを使うべし</P>
<P>// ストリームの取得<BR>
vector&lt;BYTE&gt;* GetData( );</P>
<P>// ------ 各種データの格納用オペレータ<BR>
// アーカイブ！<BR>
CSerialize&amp; operator &lt;&lt; (CArchive&amp;
vData);</P>
<P>template &lt;class T&gt;<BR>
CSerialize&amp; SerializeT (T&amp; vData);</P>
<P>// primitive data<BR>
CSerialize&amp; operator &lt;&lt; (int&amp;
nData);<BR>
CSerialize&amp; operator &lt;&lt; (bool&amp;
bData);<BR>
CSerialize&amp; operator &lt;&lt; (BYTE&amp;
byData);<BR>
CSerialize&amp; operator &lt;&lt; (string&amp;
szData);<BR>
CSerialize&amp; operator &lt;&lt; (WORD&amp;
dwData);<BR>
CSerialize&amp; operator &lt;&lt; (DWORD&amp;
dwData);</P>
<P>// vectorも！<BR>
CSerialize&amp; operator &lt;&lt; (vector&lt;int&gt;&amp;
anData);<BR>
CSerialize&amp; operator &lt;&lt; (vector&lt;bool&gt;&amp;
abData);<BR>
CSerialize&amp; operator &lt;&lt; (vector&lt;BYTE&gt;&amp;
abyData);<BR>
CSerialize&amp; operator &lt;&lt; (vector&lt;string&gt;&amp;
szData);<BR>
CSerialize&amp; operator &lt;&lt; (vector&lt;WORD&gt;&amp;
dwData);<BR>
CSerialize&amp; operator &lt;&lt; (vector&lt;DWORD&gt;&amp;
dwData);</P>
<P>// あるいは、Arrayも、、<BR>
// メンバ関数テンプレートでの実装<BR>
template &lt;class T&gt;<BR>
CSerialize&amp; Store(T* pavData,int nSize);</P>
<P>// 自分自身も！＾＾；<BR>
CSerialize&amp; operator &lt;&lt; (CSerialize&amp;
vData);</P>
<P>// -----------------------------------------------------------</P>
<P>// そして、シリアライズ間のコピー！<BR>
CSerialize&amp; operator = (CSerialize&amp;
vSeri);</P>
<P>// あまり、こういうの用意したくないが．．<BR>
LRESULT Save(string filename); // ストリームのファイルへの保存<BR>
LRESULT Load(string filename); // ストリームのファイルからの復元</P>
<P>// 使わんほうがええけどデバッグ用に<BR>
int GetPos( ) ; // ストーリームを読み出しているときのカレントポジション</P>
<P><B><FONT color="#ff0000" size="+2">☆　CSerializeのシリアライズに関する注意事項　☆</FONT></B></P>
<P>CSerializeは、現在のポジション・格納方向も同時にシリアライズします。</P>
<P>CSerialize s1,s2,s3;<BR>
s1 &lt;&lt; s2;<BR>
のようにした場合、このときs2は、普通、CSerializeの記録時は、格納方向になっているでしょうし、push_backしていくわけで、その格納位置(GetPosで返る)は、末尾になっています。</P>
<P>よって、s1から、<BR>
s1.SetStoring(false);<BR>
s1 &lt;&lt; s3;<BR>
と、デシリアライズ（復元）してすぐ、s3からすぐにデータを取り出すことは出来ません。s3からデータをデシリアライズするには、s3.SetStoring(false)として、取り出し方向にしてポジションを先頭にするという作業を行なう必要があります。</P>
<P>よくハマルので、注意しましょう。</P>
<HR>
<P><A name="CArchive"><FONT size="+2">class CArchive</FONT></A><A name="CTimeBase"></A>　<FONT color="#ff0000">【コンポーネント<FONT color="#ff0000">】</FONT></FONT></P>
<HR>
<P>// シリアライズ用アーカイブクラス</P>
<P>protected:<BR>
virtual void Serialize(CSerialize&amp;)=0;<BR>
// こいつをオーバーライドして使うといいのだ</P>
<P>例）<BR>
　　void Serialize(CSerialize&amp;s){<BR>
　　　s &lt;&lt; nData &lt;&lt; szData;<BR>
　　}</P>
<P>// こんな感じでシリアライズしたい、メンバをすべて書き出すコードを書くべし</P>
<P>そうすれば、<BR>
　　　CSerialize s;<BR>
　　　CArchive派生クラス a;<BR>
　　　s &lt;&lt; a;<BR>
とシリアライズできるようになる。</P>
<HR>
</BODY></HTML>
